#include <iostream>
#include <unordered_map>
#include <vector>
#include <cmath>
#include <string>

// Structure to represent Sensor Data
struct SensorData {
    float acceleration[3];  // Accelerometer data: x, y, z
    float gyroscope[3];     // Gyroscope data: x, y, z
    float magnetometer[3];  // Magnetometer data: x, y, z
};

// Structure to represent a Wearable Device
struct WearableDevice {
    int id;
    bool isWorn;            // Wear status
    SensorData lastData;    // Last sensor data collected
};

// Class to represent Wearable Detection System with Graph
class WearableDetectionSystem {
private:
    std::unordered_map<int, WearableDevice> devices;
    std::unordered_map<int, std::vector<int>> graph; // Graph to store connections (edges)

    // Helper function to compute magnitude of a 3D vector
    float computeMagnitude(float data[3]) {
        return sqrt(data[0] * data[0] + data[1] * data[1] + data[2] * data[2]);
    }

public:
    // Function to add a wearable device
    void addDevice(int id) {
        devices[id] = {id, false, {0, 0, 0, 0, 0, 0, 0, 0, 0}}; // Initialize with zeros
        graph[id] = {}; // Initialize the graph node
    }

    // Function to add a connection (edge) between devices
    void addConnection(int id1, int id2) {
        if (devices.find(id1) != devices.end() && devices.find(id2) != devices.end()) {
            graph[id1].push_back(id2);
            graph[id2].push_back(id1); // Assuming undirected graph
        } else {
            std::cout << "Device ID not found!" << std::endl;
        }
    }

    // Function to record sensor data
    void recordSensorData(int deviceId, const SensorData& data) {
        if (devices.find(deviceId) != devices.end()) {
            devices[deviceId].lastData = data;
        } else {
            std::cout << "Device ID not found!" << std::endl;
        }
    }

    // Function to detect wear status
    void detectWearStatus() {
        const float ACCELERATION_THRESHOLD = 1.0f; // Example threshold for wearable detection
        const float GYROSCOPE_THRESHOLD = 1.0f;    // Example threshold
        const float MAGNETOMETER_THRESHOLD = 1.0f; // Example threshold

        for (auto& device : devices) {
            float accMag = computeMagnitude(device.second.lastData.acceleration);
            float gyroMag = computeMagnitude(device.second.lastData.gyroscope);
            float magMag = computeMagnitude(device.second.lastData.magnetometer);

            if (accMag > ACCELERATION_THRESHOLD && gyroMag > GYROSCOPE_THRESHOLD && magMag > MAGNETOMETER_THRESHOLD) {
                device.second.isWorn = true;  // Device is worn
            } else {
                device.second.isWorn = false; // Device is not worn
            }
        }
    }

    // Function to display the status of wearable devices
    void displayDeviceStatus() {
        std::cout << "Wearable Device Status:" << std::endl;
        for (const auto& device : devices) {
            std::cout << "ID: " << device.second.id
                      << ", Worn: " << (device.second.isWorn ? "Yes" : "No") << std::endl;
        }
    }

    // Function to print the graph
    void displayGraph() {
        std::cout << "\nGraph Representation (Nodes and Edges):" << std::endl;
        for (const auto& node : graph) {
            std::cout << "Device " << node.first << " is connected to: ";
            for (const auto& neighbor : node.second) {
                std::cout << neighbor << " ";
            }
            std::cout << std::endl;
        }
    }
};

int main() {
    WearableDetectionSystem wds;

    // Add some devices
    wds.addDevice(1);
    wds.addDevice(2);
    wds.addDevice(3);

    // Add connections (edges) between devices
    wds.addConnection(1, 2);
    wds.addConnection(2, 3);
    wds.addConnection(1, 3);

    // Simulate recording sensor data
    SensorData data1 = {{2.0f, 1.5f, 0.8f}, {0.5f, 1.0f, 0.3f}, {1.2f, 0.9f, 1.0f}};
    SensorData data2 = {{0.5f, 0.2f, 0.1f}, {0.1f, 0.3f, 0.05f}, {0.4f, 0.3f, 0.2f}};
    SensorData data3 = {{1.5f, 1.8f, 0.5f}, {0.6f, 0.9f, 0.4f}, {0.8f, 1.2f, 0.7f}};

    wds.recordSensorData(1, data1);
    wds.recordSensorData(2, data2);
    wds.recordSensorData(3, data3);

    // Detect wear status based on thresholds
    wds.detectWearStatus();

    // Display the results
    wds.displayDeviceStatus();

    // Display the graph
    wds.displayGraph();

    return 0;
}
