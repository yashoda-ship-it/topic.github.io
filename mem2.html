<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }
        .header {
            text-align: center;
            background-color: #4CAF50;
            color: white;
            padding: 20px 0;
        }
        .section {
            padding: 20px;
            margin: 15px 20px;
            border-radius: 8px;
        }
        .section:nth-child(odd) {
            background-color: #f9f9f9;
        }
        .section:nth-child(even) {
            background-color: #e6f7ff;
        }
        .section strong {
            display: block;
            margin-top: 15px;
            font-size: 1.1em;
            color: #333;
        }
        ul {
            margin-top: 10px;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>Course Reflections</h2>
        <h3>Mem 2 - Yashoda Talawar</br>Roll number: 357</h3>
    </div>

    <div class="section">
        <strong>1. What are the kinds of problems we see in nature?</strong>
        <p>
            <strong>Iteration:</strong> Repeating tasks, like summing a list of numbers, problems like calculating compound interest.
            <br><strong>Recursion:</strong> Scenarios like Fibonacci sequence generation or solving the Tower of Hanoi involve recursive calls and factorial.
            <br><strong>Backtracking:</strong> Exploring possibilities to find a solution, like solving a maze, n-queens, or generating all possible permutations using backtracking to explore solutions.
        </p>
    </div>

    <div class="section">
        <strong>2. What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth.</strong>
        <p>
            <strong>Time Efficiency:</strong> Measures the computational time required to execute an algorithm and represents the number of basic operations performed by an algorithm.
            <br><strong>Space Efficiency:</strong> Measures the memory (storage) required by an algorithm, tracking how much memory is the input size and determining how much additional memory is needed to solve a problem.
            <br><strong>Complexity Classes and Orders of Growth:</strong>
            <ul>
                <li><strong>O(1):</strong> Constant Time: Fixed runtime regardless of input size (e.g., array access).</li>
                <li><strong>O(log n):</strong> Logarithmic Time: Runtime grows logarithmically (e.g., binary search).</li>
                <li><strong>O(n):</strong> Linear Time: Runtime grows linearly with input size (e.g., traversing an array).</li>
                <li><strong>O(n log n):</strong> Linearithmic Time: Efficient sorting algorithms like merge sort.</li>
                <li><strong>O(n²):</strong> Quadratic Time: Nested iterations (e.g., bubble sort).</li>
                <li><strong>O(2ⁿ):</strong> Exponential Time: Runtime doubles with each input addition (e.g., recursive Fibonacci).</li>
                <li><strong>O(n!):</strong> Factorial Time: Extremely inefficient (e.g., traveling salesman problem brute force).</li>
            </ul>
        </p>
    </div>

    <div class="section">
        <strong>3. Takeaway from different design principles from Chapter 2:</strong>
        <p>
            <strong>Modularity:</strong> Simplifies complex problems into smaller tasks.
            <br><strong>Abstraction:</strong> Hides implementation details to focus on solving the problem.
            <br><strong>Efficiency:</strong> Optimizing time and space complexities to improve performance.
            <br><strong>Reusability:</strong> Algorithms like dynamic programming can be applied across multiple domains.
        </p>
    </div>

    <div class="section">
        <strong>4. Importance of algorithms in solving problems:</strong>
        <p>
            Algorithms are step-by-step instructions used to solve specific problems. They are essential in:
            <ul>
                <li>Finding optimal solutions efficiently.</li>
                <li>Reducing time and memory requirements for computational problems.</li>
                <li>Improving decision-making and data analysis processes.</li>
                <li>Enhancing programming logic and implementation accuracy.</li>
            </ul>
        </p>
    </div>

    <div class="section">
        <strong>5. My overall learning from this course:</strong>
        <p>
            The course provided a solid foundation in understanding computational thinking and problem-solving techniques. I gained insights into:
            <ul>
                <li>Classifying problems into categories like iterative, recursive, and backtracking solutions.</li>
                <li>Analyzing time and space complexities for optimal algorithm design.</li>
                <li>Understanding various algorithm design principles for modular, reusable, and efficient code.</li>
            </ul>
        </p>
    </div>
</body>
</html>
