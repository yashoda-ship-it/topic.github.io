<!DOCTYPE html>
<html lang="en">
<head><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Course Reflections</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
    }
    h2, h3 {
      text-align: center;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
    }
    th {
      background-color: #f4f4f4;
      text-align: left;
    }
    p {
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h2>Course Reflections</h2>
  <h3>Mem 2 - Yashoda Talawar<br>Roll Number: 357</h3>
  
  <p><strong>5.</strong> The need for array query algorithms and their implications. Their applications and principles need to be discussed.<br>
    <strong>Ans:</strong><br>
    Array query algorithms are essential for efficiently performing operations like range queries, updates, and aggregations on array data. These algorithms optimize scenarios where frequent queries or updates need to be processed quickly, such as in real-time systems or large-scale data analysis.<br>
    <strong>Segment Trees:</strong> Used for range queries (e.g., range sum, range minimum). Enable efficient query and update operations in O(log n). Example: Finding the sum of elements in a specific range in stock market analysis.<br>
    <strong>Fenwick Tree (Binary Indexed Tree):</strong> Optimizes prefix sums and updates in O(log n) time. Example: Efficiently handling cumulative frequency counts.<br>
    <strong>Sparse Table:</strong> Ideal for static range queries where the data does not change, offering O(1) query time after O(n log n) preprocessing. Example: Finding the minimum value in a range for immutable data.<br>
    <strong>Applications:</strong> Array query algorithms are used in databases, real-time systems, search engines, and big data analysis.<br>
    <strong>Implications:</strong> They reduce the time complexity of range queries and updates, ensuring real-time performance in applications like stock analysis, leaderboards, or monitoring systems. Structures like Fenwick trees and sparse tables optimize memory usage compared to naive approaches.<br>
    <strong>Principles of Array Query Algorithms:</strong><br>
    - <strong>Divide and Conquer:</strong> Breaking down a problem into smaller subproblems.<br>
    - <strong>Greedy Strategy:</strong> Choosing immediate benefits for overall efficiency.<br>
    - <strong>Dynamic Programming:</strong> Storing subproblem results to avoid redundancy.<br>
    - <strong>Hashing:</strong> Mapping data to indices for efficient operations.<br>
    - <strong>Optimization:</strong> Utilizing advanced techniques for faster queries.
  </p>

  <p><strong>6.</strong> Differentiate between trees and graphs, their traversals, and applications.<br>
    <strong>Ans:</strong></p>
    <table>
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Tree</th>
          <th>Graph</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Structure</td>
          <td>Hierarchical, nodes connected by single paths, no cycles.</td>
          <td>Nodes connected arbitrarily, may contain cycles or multiple paths.</td>
        </tr>
        <tr>
          <td>Path between nodes</td>
          <td>One unique path between any two nodes.</td>
          <td>May have multiple or no paths between nodes.</td>
        </tr>
        <tr>
          <td>Traversals</td>
          <td>Preorder, Inorder, Postorder, Level-order.</td>
          <td>BFS, DFS.</td>
        </tr>
        <tr>
          <td>Applications</td>
          <td>Binary Search Trees, Heaps, Tries, Family trees.</td>
          <td>Social networks, GIS, Electric circuits.</td>
        </tr>
      </tbody>
    </table>

  <p><strong>7.</strong> Deliberate on sorting and searching algorithms, their techniques, and real-world connections.<br>
    <strong>Ans:</strong><br>
    <strong>Sorting Algorithms:</strong> Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort. Used in tasks like database sorting, file systems, and real-time leaderboard updates.<br>
    <strong>Searching Algorithms:</strong> Boyer-Moore, KMP, Brute Force, Rabin-Karp. Used in text editing, search engines, and DNA sequence analysis.
  </p>

  <p><strong>8.</strong> Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.<br>
    <strong>Ans:</strong><br>
    Graph algorithms like Prim’s and Kruskal’s (spanning trees) and Dijkstra’s and Bellman-Ford (shortest paths) are pivotal in telecommunications, transport networks, GIS, and logistics.
  </p>

  <p><strong>9.</strong> Discuss the different studied algorithm design techniques.<br>
    <strong>Ans:</strong><br>
    - <strong>Divide and Conquer:</strong> Breaking problems into smaller subproblems (e.g., Merge Sort).<br>
    - <strong>Dynamic Programming:</strong> Solving overlapping subproblems (e.g., Matrix Chain Multiplication).<br>
    - <strong>Greedy Algorithms:</strong> Building solutions iteratively (e.g., Kruskal’s Algorithm).<br>
    - <strong>Backtracking:</strong> Exploring all possibilities (e.g., N-Queens).<br>
    - <strong>Branch and Bound:</strong> Optimizing problem-solving by pruning paths (e.g., TSP).
  </p>
</body>
</html>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Course Reflections</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
    }
    h2, h3 {
      text-align: center;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
    }
    th {
      background-color: #f4f4f4;
      text-align: left;
    }
    p {
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h2>Course Reflections</h2>
  <h3>Mem 2 - Yashoda Talawar<br>Roll Number: 357</h3>
  
  <p><strong>5.</strong> The need for array query algorithms and their implications. Their applications and principles need to be discussed.<br>
    <strong>Ans:</strong><br>
    Array query algorithms are essential for efficiently performing operations like range queries, updates, and aggregations on array data. These algorithms optimize scenarios where frequent queries or updates need to be processed quickly, such as in real-time systems or large-scale data analysis.<br>
    <strong>Segment Trees:</strong> Used for range queries (e.g., range sum, range minimum). Enable efficient query and update operations in O(log n). Example: Finding the sum of elements in a specific range in stock market analysis.<br>
    <strong>Fenwick Tree (Binary Indexed Tree):</strong> Optimizes prefix sums and updates in O(log n) time. Example: Efficiently handling cumulative frequency counts.<br>
    <strong>Sparse Table:</strong> Ideal for static range queries where the data does not change, offering O(1) query time after O(n log n) preprocessing. Example: Finding the minimum value in a range for immutable data.<br>
    <strong>Applications:</strong> Array query algorithms are used in databases, real-time systems, search engines, and big data analysis.<br>
    <strong>Implications:</strong> They reduce the time complexity of range queries and updates, ensuring real-time performance in applications like stock analysis, leaderboards, or monitoring systems. Structures like Fenwick trees and sparse tables optimize memory usage compared to naive approaches.<br>
    <strong>Principles of Array Query Algorithms:</strong><br>
    - <strong>Divide and Conquer:</strong> Breaking down a problem into smaller subproblems.<br>
    - <strong>Greedy Strategy:</strong> Choosing immediate benefits for overall efficiency.<br>
    - <strong>Dynamic Programming:</strong> Storing subproblem results to avoid redundancy.<br>
    - <strong>Hashing:</strong> Mapping data to indices for efficient operations.<br>
    - <strong>Optimization:</strong> Utilizing advanced techniques for faster queries.
  </p>

  <p><strong>6.</strong> Differentiate between trees and graphs, their traversals, and applications.<br>
    <strong>Ans:</strong></p>
    <table>
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Tree</th>
          <th>Graph</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Structure</td>
          <td>Hierarchical, nodes connected by single paths, no cycles.</td>
          <td>Nodes connected arbitrarily, may contain cycles or multiple paths.</td>
        </tr>
        <tr>
          <td>Path between nodes</td>
          <td>One unique path between any two nodes.</td>
          <td>May have multiple or no paths between nodes.</td>
        </tr>
        <tr>
          <td>Traversals</td>
          <td>Preorder, Inorder, Postorder, Level-order.</td>
          <td>BFS, DFS.</td>
        </tr>
        <tr>
          <td>Applications</td>
          <td>Binary Search Trees, Heaps, Tries, Family trees.</td>
          <td>Social networks, GIS, Electric circuits.</td>
        </tr>
      </tbody>
    </table>

  <p><strong>7.</strong> Deliberate on sorting and searching algorithms, their techniques, and real-world connections.<br>
    <strong>Ans:</strong><br>
    <strong>Sorting Algorithms:</strong> Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quick Sort. Used in tasks like database sorting, file systems, and real-time leaderboard updates.<br>
    <strong>Searching Algorithms:</strong> Boyer-Moore, KMP, Brute Force, Rabin-Karp. Used in text editing, search engines, and DNA sequence analysis.
  </p>

  <p><strong>8.</strong> Discuss the importance of graph algorithms with respect to spanning trees and shortest paths.<br>
    <strong>Ans:</strong><br>
    Graph algorithms like Prim’s and Kruskal’s (spanning trees) and Dijkstra’s and Bellman-Ford (shortest paths) are pivotal in telecommunications, transport networks, GIS, and logistics.
  </p>

  <p><strong>9.</strong> Discuss the different studied algorithm design techniques.<br>
    <strong>Ans:</strong><br>
    - <strong>Divide and Conquer:</strong> Breaking problems into smaller subproblems (e.g., Merge Sort).<br>
    - <strong>Dynamic Programming:</strong> Solving overlapping subproblems (e.g., Matrix Chain Multiplication).<br>
    - <strong>Greedy Algorithms:</strong> Building solutions iteratively (e.g., Kruskal’s Algorithm).<br>
    - <strong>Backtracking:</strong> Exploring all possibilities (e.g., N-Queens).<br>
    - <strong>Branch and Bound:</strong> Optimizing problem-solving by pruning paths (e.g., TSP).
  </p>
</body>
</html>


