<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }
        .header {
            text-align: center;
            background-color: #4CAF50;
            color: white;
            padding: 20px 0;
        }
        .section {
            padding: 20px;
            margin: 15px 20px;
            border-radius: 8px;
        }
        .section:nth-child(odd) {
            background-color: #f9f9f9;
        }
        .section:nth-child(even) {
            background-color: #e6f7ff;
        }
        .section strong {
            display: block;
            margin-top: 15px;
            font-size: 1.1em;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>Course Reflections</h2>
        <h3>Mem 2 - Yashoda Talawar</br>Roll number: 357</h3>
    </div>

    <div class="section">
        <strong>1. What are the kinds of problems we see in nature?</strong>
        <p>
            <strong>Iteration:</strong> Repeating tasks, like summing a list of numbers, problems like calculating compound interest.<br>
            <strong>Recursion:</strong> Scenarios like Fibonacci sequence generation or solving the Tower of Hanoi involve recursive calls and factorial.<br>
            <strong>Backtracking:</strong> Exploring possibilities to find a solution, like solving a maze, n-queens, or generating all possible permutations using backtracking to explore solutions.
        </p>
    </div>

    <div class="section">
        <strong>2. What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth.</strong>
        <p>
            <strong>Time Efficiency:</strong> Measures the computational time required to execute an algorithm and represents the number of basic operations performed by an algorithm.<br>
            <strong>Space Efficiency:</strong> Measures the memory (storage) required by an algorithm, tracking how much memory is the input size and determining how much additional memory is needed to solve a problem.<br>
            <strong>Complexity Classes and Orders of Growth:</strong><br>
            <strong>O(1):</strong> Constant Time: Fixed runtime regardless of input size (e.g., array access).<br>
            <strong>O(log n):</strong> Logarithmic Time: Runtime grows logarithmically (e.g., binary search).<br>
            <strong>O(n):</strong> Linear Time: Runtime grows linearly with input size (e.g., traversing an array).<br>
            <strong>O(n log n):</strong> Linearithmic Time: Efficient sorting algorithms like merge sort.<br>
            <strong>O(n²):</strong> Quadratic Time: Nested iterations (e.g., bubble sort).<br>
            <strong>O(2ⁿ):</strong> Exponential Time: Runtime doubles with each input addition (e.g., recursive Fibonacci).<br>
            <strong>O(n!):</strong> Factorial Time: Extremely inefficient (e.g., traveling salesman problem brute force).
        </p>
    </div>

    <div class="section">
        <strong>3. Takeaway from different design principles from Chapter 2:</strong>
        <p>
            <strong>Modularity:</strong> Simplifies complex problems into smaller tasks.<br>
            <strong>Abstraction:</strong> Hides implementation details to focus on solving the problem.<br>
            <strong>Efficiency:</strong> Optimizing time and space complexities to improve performance.<br>
            <strong>Reusability:</strong> Algorithms like dynamic programming can be applied across multiple domains.
        </p>
    </div>

    <div class="section">
        <strong>4. Importance of algorithms in solving problems:</strong>
        <p>
            Algorithms are step-by-step instructions used to solve specific problems. They are essential in:<br>
            - Finding optimal solutions efficiently.<br>
            - Reducing time and memory requirements for computational problems.<br>
            - Improving decision-making and data analysis processes.<br>
            - Enhancing programming logic and implementation accuracy.
        </p>
    </div>

    <div class="section">
        <strong>5. My overall learning from this course:</strong>
        <p>
            The course provided a solid foundation in understanding computational thinking and problem-solving techniques. I gained insights into:<br>
            - Classifying problems into categories like iterative, recursive, and backtracking solutions.<br>
            - Analyzing time and space complexities for optimal algorithm design.<br>
            - Understanding various algorithm design principles for modular, reusable, and efficient code.
        </p>
    </div>

    <div class="section">
        <strong>6. How to approach problem-solving and its importance:</strong>
        <p>
            Problem-solving is the process of identifying, analyzing, and solving problems systematically. Its importance includes:<br>
            - Enhancing critical thinking and logical reasoning.<br>
            - Breaking down complex problems into simpler subproblems.<br>
            - Applying algorithmic approaches to find optimal solutions.<br>
            - Adapting to dynamic challenges in computational scenarios.
        </p>
    </div>

    <div class="section">
        <strong>7. Real-world applications of algorithms:</strong>
        <p>
            Algorithms are widely used in real-world applications such as:<br>
            - Search engines (Google, Bing) using search algorithms.<br>
            - Route optimization in GPS navigation.<br>
            - Cryptography for secure communication.<br>
            - Recommendation systems in e-commerce and streaming platforms.<br>
            - Machine learning and AI to analyze large datasets.
        </p>
    </div>

    <div class="section">
        <strong>8. Challenges faced during the course and solutions:</strong>
        <p>
            <strong>Challenges:</strong><br>
            - Understanding complex algorithms like dynamic programming and backtracking.<br>
            - Analyzing time and space complexities effectively.<br>
            - Applying theoretical concepts to practical problems.<br>
            <strong>Solutions:</strong><br>
            - Practicing problems on platforms like LeetCode and HackerRank.<br>
            - Referring to additional resources and tutorials for clarity.<br>
            - Participating in group discussions and asking for guidance when needed.
        </p>
    </div>

    <div class="section">
        <strong>9. Importance of modularity and reusability:</strong>
        <p>
            Modularity and reusability are crucial in programming because:<br>
            - They simplify the development process by dividing tasks into smaller, manageable modules.<br>
            - Reusable modules save time and effort by applying the same logic to multiple projects.<br>
            - Encourage clean, maintainable, and scalable code.<br>
            - Facilitate debugging by isolating issues within specific modules.
        </p>
    </div>
</body>
</html>
