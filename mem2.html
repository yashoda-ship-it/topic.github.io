<h2>Course Reflections</h2>
<h3>Mem 2 - Yashoda Talawar</br>Roll number : 357</h3>
<p> <strong>1.</strong>What are the kinds of problems we see in the nature?
<strong></br>Ans:</br></strong><strong>Iteration:</strong>Repeating tasks, like summing a list of numbers,Problems like calculating compound interest.
</br><strong>
  Recursion:</strong>Scenarios like Fibonacci sequence generation or solving the Tower of Hanoi involve recursive calls and factorial
</br>
<strong>Backtracking:</strong> Exploring possibilities to find a solution, like solving a maze,n-queens, or generating all possible permutations use backtracking to explore solutions.
</p>

<p>2.What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth
  <strong></br>Ans:</br>Space Efficiency:</strong>It Refers to how much memory (or storage) an algorithm uses while solving a problem.
</br><strong>Example:</strong> An algorithm that requires less RAM is more space-efficient.</br><strong> Time Efficiency:</strong>It Refers to how much time an algorithm takes to solve a problem as the input size increases.</br><strong>Example:</strong>
An algorithm that runs faster as data grows is time-efficient.</br></br><strong>Why are They Important?</strong></br></br>
<strong>Resource Management:</strong></br>Efficient algorithms save memory and time, which is crucial for limited resources in real-world systems.
</br><strong>Scalability:</strong></br>With increasing input sizes, efficient algorithms ensure performance doesnâ€™t degrade.
</br><strong>Real-Time Applications:</strong></br>
Faster, efficient solutions are vital in applications like GPS, healthcare, AI, and large-scale data processing.</br>
<strong></br>Different Classes of Problems</strong></br></br><strong>Computational Problems: </strong>Problems requiring algorithms for problem-solving (sorting, searching).</br>
<strong>Optimization Problems:</strong> Finding the best solution out of many possibilities (shortest path, resource allocation).</br>
<strong>Decision Problems:</strong> Determining whether a given condition is true or false for a problem.</br>
<strong>Search Problems:</strong> Locating specific information from a large dataset (like finding a word in a dictionary).</br></p>

<p>3.Take away from different design principles from chapter 2
 <strong></br>Modularity:</strong> Simplifies complex problems into smaller tasks.
<strong></br>Abstraction:</strong> Hides implementation details to focus on solving the problem.
<strong></br>Efficiency: </strong>Optimizing time and space complexities to improve performance.
<strong></br>Reusability:</strong>Algorithms like dynamic programming can be applied across multiple domains.</p>

<p><strong>4.</strong>The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)
<strong></br>General Tree:</strong>
Represents basic parent-child relationships but lacks specific balancing properties.
<strong></br>Binary Search Tree (BST):</strong>
Organizes data such that left children are smaller and right children are larger than the parent. It offers efficient searching and insertion with an average time complexity of O(log n), but performance can degrade to O(n) if unbalanced.
<strong></br>AVL Tree:</strong>
A self-balancing BST ensuring all operations (search, insert, delete) are consistently O(log n). It's ideal for real-time systems due to its guaranteed balance.
<strong></br>Heap:</strong>
Maintains the property where the root is always the maximum or minimum value. It's commonly used in priority queues and task scheduling, with insertion and deletion at O(log n) and fast root access at O(1).
<strong></br>Trie:</strong>
Optimized for prefix-based searches, where each branch represents a character. It's widely used in autocomplete and dictionary lookups, offering fast search but higher memory usage.
<strong></br>Choosing the right tree:</strong>
<strong></br>Trie:</strong> For prefix-based searches or autocomplete.
<strong></br>Heap:</strong> For priority queues and scheduling.
<strong></br>AVL/Red-Black Trees:</strong> For frequent searching and updates in ordered data.
<strong></br>General Tree:</strong> For simple parent-child relationships without balancing needs.
</p>
 
