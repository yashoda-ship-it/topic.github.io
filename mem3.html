<h2>Course Reflections</h2>
<h3>Mem 3 - Preeti Kotabagi</h3>
<p> 1.What are the kinds of problems we see in the nature?</p>
 <p> <strong>Ans:</strong><strong>Iteration:</strong>Repeating processes like the water cycle or animals gathering food.</br><strong>
  Recursion:</strong>Self-similar patterns like tree branching, fractals, or the food chain.</br>
<strong>Backtracking:</strong>Trial-and-error processes like ants finding food or birds building nests.</p>
<p>2.What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth</p>
  <p><strong>Ans:</br>Space Efficiency:</strong>It Refers to how much memory (or storage) an algorithm uses while solving a problem.
</br><strong>Example:</strong> An algorithm that requires less RAM is more space-efficient.</br><strong> Time Efficiency:</strong>It Refers to how much time an algorithm takes to solve a problem as the input size increases.</br><strong>Example:</strong>
An algorithm that runs faster as data grows is time-efficient.</br></br><strong>Why are They Important?</strong></br></br>
<strong>Resource Management:</strong></br>Efficient algorithms save memory and time, which is crucial for limited resources in real-world systems.
</br><strong>Scalability:</strong></br>With increasing input sizes, efficient algorithms ensure performance doesnâ€™t degrade.
</br><strong>Real-Time Applications:</strong></br>
Faster, efficient solutions are vital in applications like GPS, healthcare, AI, and large-scale data processing.</br>
<strong></br>Different Classes of Problems</strong></br></br><strong>Computational Problems: </strong>Problems requiring algorithms for problem-solving (sorting, searching).</br>
<strong>Optimization Problems:</strong> Finding the best solution out of many possibilities (shortest path, resource allocation).</br>
<strong>Decision Problems:</strong> Determining whether a given condition is true or false for a problem.</br>
<strong>Search Problems:</strong> Locating specific information from a large dataset (like finding a word in a dictionary).</br></p>
<p>3.Take away from different design principles from chapter 2</p>
 <p></p>
<p>4.The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)</p>
  <p><strong>Ans:</br></strong><strong>Hierarchical Data & Tree Data Structures</br></strong>
  Hierarchical data shows parent-child relationships and can be effectively represented using tree data structures. These trees have special properties that make operations faster, depending on their type and purpose.
</br></br>
<strong>General Tree:</br></strong>
A binary search tree (BST) is a special kind of binary tree where the left child is smaller, and the right child is greater than the parent. It allows efficient searching and inserting with an average time of O(log n). But if it gets unbalanced, performance can drop to O(n).</br>
<strong>AVL Tree:</br></strong>An AVL Tree is a balanced version of a binary search tree. It keeps itself balanced by ensuring a strict condition at every node. Because of this, operations like searching, inserting, and deleting have a guaranteed time of O(log n), even in the worst case. It's ideal for real-time systems.
</br></br>
<strong>Red-Black Tree:</br></strong>A Red-Black Tree is another type of self-balancing binary search tree. It uses a color system (red or black) to quickly balance itself, requiring fewer adjustments than AVL trees. It works efficiently for tasks like database indexing and managing ordered data.
</br></br>
<strong>2-3 Tree:</br></strong>A 2-3 tree is a balanced tree where each node can have two or three children. It is great for database indexing and supports efficient searching and inserting with a time complexity of O(log n). It's an alternative to B-Trees for managing ordered datasets.
</br></br><strong>Heap</br></strong>A heap is a type of tree that maintains a property where the largest or smallest value is always at the root. Heaps are used in priority queues, scheduling tasks, and sorting. They allow fast access to the maximum or minimum value in O(1) time and insertion or deletion in O(log n).
</br></br><strong>Trie</br></strong>A Trie, or prefix tree, is a tree optimized for storing and searching strings. Each branch represents a single character, which makes prefix-based lookups very fast. They're commonly used in features like autocomplete, dictionary lookups, or routing. However, they use a lot of memory for very large datasets.
</br></br><strong>Choosing the Right Tree:</br></strong><strong>Trie:</strong>Best for autocomplete or prefix-based searches.</br>
</br><strong>Heap:</strong> Great for priority queues or task scheduling.</br>
</br><strong>AVL Tree or Red-Black Tree:</strong>Use these for frequent searching and inserting in ordered data.</br>
</br><strong>General Trees:</strong>Best for situations with simple parent-child relationships that don't need balancing.</br></p>
<p>5.The need of array query algorithms and their implications. Their applications and principles need to be discussed</p>
 <p> Ans:</p>
<p>6.Differentiate between tree and graphs and their traversals. The applications of each</p>
  <p>Ans:</p>
<p>7.Deliberate on sorting and searching algorithms, the technique behind each and they connect to real world</p>
  <p>Ans</p>
<p>8.Discuss the importance of graph algorithms with respect to spanning trees and shortest paths</p>
<p>Ans:</p>
<p>9.Discuss about the different studied algorithm design techniques.</p>
<p>Ans:      </p>
