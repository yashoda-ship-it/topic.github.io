<h2>Course Reflections</h2>
<h3>Mem 3 - Preeti Kotabagi</h3>
<p> 1.What are the kinds of problems we see in the nature?</p>
 <p> <strong>Ans:</strong><strong>Iteration:</strong>Repeating processes like the water cycle or animals gathering food.</br><strong>
  Recursion:</strong>Self-similar patterns like tree branching, fractals, or the food chain.</br>
<strong>Backtracking:</strong>Trial-and-error processes like ants finding food or birds building nests.</p>
<p>2.What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth</p>
  <p><strong>Ans:</br>Space Efficiency:</strong>It Refers to how much memory (or storage) an algorithm uses while solving a problem.
</br><strong>Example:</strong> An algorithm that requires less RAM is more space-efficient.</br><strong> Time Efficiency:</strong>It Refers to how much time an algorithm takes to solve a problem as the input size increases.</br><strong>Example:</strong>
An algorithm that runs faster as data grows is time-efficient.</br></br><strong>Why are They Important?</strong></br></br>
<strong>Resource Management:</strong></br>Efficient algorithms save memory and time, which is crucial for limited resources in real-world systems.
</br><strong>Scalability:</strong></br>With increasing input sizes, efficient algorithms ensure performance doesnâ€™t degrade.
</br><strong>Real-Time Applications:</strong></br>
Faster, efficient solutions are vital in applications like GPS, healthcare, AI, and large-scale data processing.</br>
<strong></br>Different Classes of Problems</strong></br></br><strong>Computational Problems: </strong>Problems requiring algorithms for problem-solving (sorting, searching).</br>
<strong>Optimization Problems:</strong> Finding the best solution out of many possibilities (shortest path, resource allocation).</br>
<strong>Decision Problems:</strong> Determining whether a given condition is true or false for a problem.</br>
<strong>Search Problems:</strong> Locating specific information from a large dataset (like finding a word in a dictionary).</br></p>
<p>3.Take away from different design principles from chapter 2</p>
 <p></p>
<p>4.The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)</p>
  <p>Ans:</p>
<p>5.The need of array query algorithms and their implications. Their applications and principles need to be discussed</p>
 <p> Ans:</p>
<p>6.Differentiate between tree and graphs and their traversals. The applications of each</p>
  <p>Ans:</p>
<p>7.Deliberate on sorting and searching algorithms, the technique behind each and they connect to real world</p>
  <p>Ans</p>
<p>8.Discuss the importance of graph algorithms with respect to spanning trees and shortest paths</p>
<p>Ans:</p>
<p>9.Discuss about the different studied algorithm design techniques.</p>
<p>Ans:      </p>
